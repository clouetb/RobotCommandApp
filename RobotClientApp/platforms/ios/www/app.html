<!DOCTYPE html>
<html>
    <head>
        <meta name="keywords" content="JavaScript, WebRTC">
        <meta name="description" content="WebRTC codelab">
        <meta name="viewport" content="user-scalable=no, width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1, minimum-scale=1">
        <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' data: gap: https://ssl.gstatic.com 'unsafe-eval'; style-src 'self' 'unsafe-inline'; media-src *; connect-src *">
        <title>
            Robot control application
        </title>
        <style type="text/css">
        body {
            margin-top: 0px;
            margin-left: 0px;
            background-color: #000000;
        }
        canvas {
            position: relative;
            top: 0;
            left: 0;
        }
        #remoteVideos video {
            position: relative;
            top: 0;
            left: 0;
            object-fit: cover;
        }
        #localVideo {
            z-index:1;
            position: absolute;
            top: 20px;
            left: 20px;
        }
        </style>
        <script src="js/simplewebrtc.latest.js" type="text/javascript"></script>
        <script src="cordova.js" type="text/javascript"></script>
    </head>
    <body>
        <div style="position: relative; left: 0; top: 0;">
            <div id="remoteVideos"></div>
            <video id="localVideo"></video>
        </div>
        <script type="text/javascript">
        var remoteVideos = window.document.getElementById("remoteVideos");
        var localVideo = window.document.getElementById("localVideo");
         // Worker for handling results of touches
        var worker = new Worker("js/communication_worker.js");
        var webtrc = {};
         // Set of fingers
        var leftFinger = {
            // Used for later identification
            id: 0,
            x: 0,
            y: 0,
            offset: 0,
            active: false
        };
        var rightFinger = {
            // Used for later identification
            id: 0,
            x: 0,
            y: 0,
            offset: 0,
            active: false
        };
         // Initialized on startup
        var savedGeometry = {
            width: 0,
            height: 0
        };

        function initDeviceGeometryAndElements() {
            // Get the orientation angle
            var angle = window.orientation.toFixed();
            if (angle == 0 || angle == 180) {
                // Portrait
                savedGeometry.height = window.document.height;
                savedGeometry.width = window.document.width;
            } else {
                // Landscape
                savedGeometry.height = window.document.width;
                savedGeometry.width = window.document.height;
            }
        }

        function resizeElements() {
            // Size of the local video thumbnail
            var localImageRatio = .2;
            // Get the orientation angle
            var angle = window.orientation.toFixed();
            if (angle == 0 || angle == 180) {
                // Portrait mode
                // Only work on remote video element
                for (var i = 0; i < remoteVideos.childNodes.length; i++) {
                    remoteVideos.childNodes[i].width = savedGeometry.width;
                    remoteVideos.childNodes[i].height = savedGeometry.height;
                }
            } else {
                // Landscape mode
                // Only work on remote video element
                for (var i = 0; i < remoteVideos.childNodes.length; i++) {
                    remoteVideos.childNodes[i].width = savedGeometry.height
                    remoteVideos.childNodes[i].height = savedGeometry.width;;
                }
            }
            // Resize the local video to the thumbnail size
            localVideo.width = localVideo.videoWidth * localImageRatio;
            localVideo.height = localVideo.videoHeight * localImageRatio;
            // Force redisplay
            cordova.plugins.iosrtc.refreshVideos();
        }

         // Only used for logging on the console
        worker.onmessage = function(e) {
            console.log(e.data);
        }

        window.addEventListener("load", function() {
                console.log("Robot app >>> DOM loaded");

                document.addEventListener("deviceready", function() {
                        console.log("Robot app >>> deviceready event");

                        initDeviceGeometryAndElements();
                        resizeElements();

                        // Try to reestablish connection when resuming application
                        document.addEventListener("resume", function() {
                            webrtc = new SimpleWebRTC({
                                // the id/element dom element that will hold "our" video
                                localVideoEl: 'localVideo',
                                // the id/element dom element that will hold remote videos
                                remoteVideosEl: 'remoteVideos',
                                // immediately ask for camera access
                                autoRequestMedia: true,
                                // required for working on my iPhone
                                detectSpeakingEvents: false,
                                debug: true
                            });
                            initDeviceGeometryAndElements();
                            resizeElements();
                        }, false); // resume

                        // Register touchstart event processing
                        document.addEventListener("touchstart", function(event) {
                            console.log("Touch start");
                            event.preventDefault();
                            for (var i = 0; i < event.changedTouches.length; i++) {
                                var touch = event.changedTouches[i];
                                // Left finger only the first touch
                                if ((touch.pageX < (document.width / 2)) && !leftFinger.active) {
                                    //console.log("touch start on left");
                                    // Save finger initial state
                                    leftFinger.id = touch.identifier;
                                    leftFinger.x = touch.pageX;
                                    leftFinger.y = touch.pageY;
                                    leftFinger.active = true;
                                } else
                                // Right finger only the first touch
                                if ((touch.pageX >= (document.width / 2)) && !rightFinger.active) {
                                    //console.log("touch start on right");
                                    // Save finger initial state
                                    rightFinger.id = touch.identifier;
                                    rightFinger.x = touch.pageX;
                                    rightFinger.y = touch.pageY;
                                    rightFinger.active = true;
                                }
                            }
                        }, false); // touch start

                        // Register touchmove event processing
                        document.addEventListener("touchmove", function(event) {
                            event.preventDefault();
                            for (var i = 0; i < event.changedTouches.length; i++) {
                                var touch = event.changedTouches[i];
                                // Check which finger
                                if (leftFinger.id == touch.identifier) {
                                    // Left finger offset = start position - current position
                                    leftFinger.offset = leftFinger.y - touch.pageY;
                                    //console.log("move on left offset " + leftFinger.offset);
                                } else
                                if (rightFinger.id == touch.identifier) {
                                    // Right finger offset = start position - current position
                                    rightFinger.offset = rightFinger.y - touch.pageY;
                                    //console.log("move on right offset " + rightFinger.offsetY);
                                }
                            }
                            // Send fingers position to the worker
                            worker.postMessage([leftFinger, rightFinger]);
                        }, false); // touch move

                        // Register touchend event processing
                        document.addEventListener("touchend", function(event) {
                            console.log("Touch start");
                            for (var i = 0; i < event.changedTouches.length; i++) {
                                var touch = event.changedTouches[i];
                                if (leftFinger.id == touch.identifier) {
                                    // Reset left finger offset
                                    leftFinger.offset = 0;
                                    leftFinger.active = false;
                                } else
                                if (rightFinger.id == touch.identifier) {
                                    // Reset right finger offset
                                    rightFinger.offset = 0;
                                    rightFinger.active = false;
                                }
                            }
                            // Send fingers position to the worker
                            worker.postMessage([leftFinger, rightFinger]);
                        }, false); // touch end

                        window.addEventListener('orientationchange', function() {
                            console.log("Robot app >>> Orientation change");
                            var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/g);
                            var viewportmeta = document.querySelector('meta[name="viewport"]');
                            if (iOS && viewportmeta) {
                                if (viewportmeta.content.match(/width=device-width/)) {
                                    viewportmeta.content = viewportmeta.content.replace(/width=[^,]+/, 'width=1');
                                }
                                viewportmeta.content = viewportmeta.content.replace(/width=[^,]+/, 'width=' + window.innerWidth);
                            }
                            resizeElements();
                        }, false); // orientation change

                        // if iOS devices
                        if (window.device.platform === "iOS") {
                            cordova.plugins.iosrtc.debug.enable("*");

                            // Pollute global namespace with WebRTC stuff.
                            cordova.plugins.iosrtc.registerGlobals();
                            console.log("Robot app >>> Globals registered");
                        }

                        // Init webrtc session
                        webrtc = new SimpleWebRTC({
                            // the id/element dom element that will hold "our" video
                            localVideoEl: 'localVideo',
                            // the id/element dom element that will hold remote videos
                            remoteVideosEl: 'remoteVideos',
                            // immediately ask for camera access
                            autoRequestMedia: true,
                            // required for working on my iPhone
                            detectSpeakingEvents: false,
                            debug: true
                        });

                        // we have to wait until it's ready
                        webrtc.on('readyToCall', function() {
                            // you can name it anything
                            webrtc.joinRoom('PrivateRoomForMyRobot_BCL');
                        });

                        // Rearrange elements once the remote video is displayed
                        webrtc.on('videoAdded', function(video, peer) {
                            //console.log('video added', peer);
                            initDeviceGeometryAndElements();
                            resizeElements();
                        });

                    }, false); // device ready

                }, false); // load

</script>
</body>

</html>